use std::fs;

use anyhow::Result;
use duct::cmd;

use crate::{
    envcfg::EnvConfig,
    fsops::{io_atom::write_atomic, layout::MailLayout},
    util::logging::{LogLevel, Logger},
};

pub fn provision(layout: &MailLayout, env: &EnvConfig, logger: &Logger) -> Result<()> {
    apply_secure_umask();
    create_postfix_config(layout, env)?;
    create_rspamd_config(layout)?;
    create_letsencrypt_docs(layout, env)?;
    create_rate_limit_marker(layout)?;
    run_certbot(layout, env, logger)?;
    enable_rspamd(logger)?;
    reload_postfix(logger)?;
    sync_chrony(logger)?;
    logger.log(
        LogLevel::Minimal,
        "install.ops.provisioned",
        Some(&format!(
            "postfix={} rspamd={} letsencrypt={}",
            layout.root().join("config/postfix/main.cf").display(),
            layout
                .root()
                .join("config/rspamd/local.d/rate_limit.conf")
                .display(),
            layout
                .root()
                .join("config/letsencrypt/README.txt")
                .display()
        )),
    )?;
    Ok(())
}

fn create_postfix_config(layout: &MailLayout, env: &EnvConfig) -> Result<()> {
    let postfix_dir = layout.root().join("config/postfix");
    fs::create_dir_all(&postfix_dir)?;
    let main_cf = postfix_dir.join("main.cf");
    let content = format!(
        concat!(
            "# Generated by owl install\n",
            "smtpd_tls_cert_file = {cert}\n",
            "smtpd_tls_key_file = {key}\n",
            "smtpd_use_tls = yes\n",
            "smtp_tls_security_level = may\n",
            "smtpd_recipient_limit = 100\n",
            "smtp_destination_rate_delay = 1s\n",
            "smtpd_client_connection_count_limit = 10\n",
            "smtpd_client_connection_rate_limit = 30\n",
            "smtpd_client_message_rate_limit = 100\n",
            "default_process_limit = 100\n",
            "smtp_tls_note_starttls_offer = yes\n",
            "smtp_tls_loglevel = 1\n",
            "queue_run_delay = 300s\n",
            "minimal_backoff_time = 300s\n",
            "maximal_backoff_time = 1800s\n",
            "smtp_fallback_relay = {relay}\n"
        ),
        cert = layout
            .root()
            .join("config/letsencrypt/live/fullchain.pem")
            .display(),
        key = layout
            .root()
            .join("config/letsencrypt/live/privkey.pem")
            .display(),
        relay = env.smtp_host.clone().unwrap_or_else(|| "127.0.0.1".into()),
    );
    write_atomic(&main_cf, content.as_bytes())?;
    let master_cf = postfix_dir.join("master.cf");
    let master_body = "smtp      inet  n       -       y       -       -       smtpd\n";
    write_atomic(&master_cf, master_body.as_bytes())?;
    let rate_cf = postfix_dir.join("rate_limit.cf");
    let rate_body = "# Simple rate limits to mitigate abuse\n/postfix/smtpd/ recipient_limit=100\n";
    write_atomic(&rate_cf, rate_body.as_bytes())?;
    Ok(())
}

fn create_rspamd_config(layout: &MailLayout) -> Result<()> {
    let rspamd_dir = layout.root().join("config/rspamd/local.d");
    fs::create_dir_all(&rspamd_dir)?;
    let rate_limit = rspamd_dir.join("rate_limit.conf");
    let body = concat!(
        "# Generated by owl install\n",
        "rate_limit {\n",
        "  symbol = \"RATELIMIT\";\n",
        "  bucket_size = 50;\n",
        "  burst = 10;\n",
        "  rate = 30;\n",
        "}\n"
    );
    write_atomic(&rate_limit, body.as_bytes())?;
    Ok(())
}

fn create_letsencrypt_docs(layout: &MailLayout, env: &EnvConfig) -> Result<()> {
    let lets_dir = layout.root().join("config/letsencrypt");
    fs::create_dir_all(&lets_dir)?;
    let readme = lets_dir.join("README.txt");
    let content = format!(
        "Method: {}\nRun certbot with --manual for initial provisioning. Certificates stored under ./live.\n",
        env.letsencrypt_method
    );
    write_atomic(&readme, content.as_bytes())?;
    let hooks_dir = lets_dir.join("hooks");
    fs::create_dir_all(&hooks_dir)?;
    write_atomic(
        &hooks_dir.join("reload-postfix.sh"),
        b"#!/bin/sh\nsystemctl reload postfix\n",
    )?;
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let perms = fs::Permissions::from_mode(0o700);
        fs::set_permissions(hooks_dir.join("reload-postfix.sh"), perms)?;
    }
    Ok(())
}

fn create_rate_limit_marker(layout: &MailLayout) -> Result<()> {
    let ops_dir = layout.root().join("logs");
    fs::create_dir_all(&ops_dir)?;
    let chrony = ops_dir.join("chrony-sync.log");
    if !chrony.exists() {
        write_atomic(&chrony, b"chrony sync simulated\n")?;
    }
    Ok(())
}

fn run_certbot(layout: &MailLayout, env: &EnvConfig, logger: &Logger) -> Result<()> {
    let config_dir = layout.root().join("config/letsencrypt");
    let work_dir = config_dir.join("work");
    let logs_dir = config_dir.join("logs");
    fs::create_dir_all(&work_dir)?;
    fs::create_dir_all(&logs_dir)?;
    let hook = config_dir.join("hooks/reload-postfix.sh");
    let domain = env.smtp_host.clone().unwrap_or_else(|| "localhost".into());
    let email_domain = domain.trim_start_matches("smtp.").to_string();
    let email = format!("postmaster@{email_domain}");
    let mut args = vec![
        "certonly".to_string(),
        "--non-interactive".into(),
        "--agree-tos".into(),
        "--config-dir".into(),
        config_dir.to_string_lossy().into(),
        "--work-dir".into(),
        work_dir.to_string_lossy().into(),
        "--logs-dir".into(),
        logs_dir.to_string_lossy().into(),
        "--deploy-hook".into(),
        hook.to_string_lossy().into(),
        "--email".into(),
        email,
        "-d".into(),
        domain.clone(),
    ];
    if env.letsencrypt_method.eq_ignore_ascii_case("http") {
        args.push("--preferred-challenges".into());
        args.push("http".into());
        args.push("--standalone".into());
    }
    cmd("certbot", args)
        .stderr_capture()
        .stdout_capture()
        .run()
        .inspect_err(|err| {
            let _ = logger.log(
                LogLevel::Minimal,
                "install.ops.certbot.error",
                Some(&err.to_string()),
            );
        })?;
    logger.log(
        LogLevel::Minimal,
        "install.ops.certbot",
        Some(&format!("domain={domain}")),
    )?;
    Ok(())
}

fn enable_rspamd(logger: &Logger) -> Result<()> {
    cmd("rspamadm", ["configtest"])
        .stderr_capture()
        .stdout_capture()
        .run()
        .inspect_err(|err| {
            let _ = logger.log(
                LogLevel::Minimal,
                "install.ops.rspamd.error",
                Some(&err.to_string()),
            );
        })?;
    cmd("systemctl", ["enable", "rspamd"])
        .stderr_capture()
        .stdout_capture()
        .run()
        .inspect_err(|err| {
            let _ = logger.log(
                LogLevel::Minimal,
                "install.ops.rspamd.enable_error",
                Some(&err.to_string()),
            );
        })?;
    cmd("systemctl", ["restart", "rspamd"])
        .stderr_capture()
        .stdout_capture()
        .run()
        .inspect_err(|err| {
            let _ = logger.log(
                LogLevel::Minimal,
                "install.ops.rspamd.restart_error",
                Some(&err.to_string()),
            );
        })?;
    logger.log(LogLevel::Minimal, "install.ops.rspamd", None)?;
    Ok(())
}

fn reload_postfix(logger: &Logger) -> Result<()> {
    cmd("systemctl", ["reload", "postfix"])
        .stderr_capture()
        .stdout_capture()
        .run()
        .inspect_err(|err| {
            let _ = logger.log(
                LogLevel::Minimal,
                "install.ops.postfix.error",
                Some(&err.to_string()),
            );
        })?;
    logger.log(LogLevel::Minimal, "install.ops.postfix", None)?;
    Ok(())
}

fn sync_chrony(logger: &Logger) -> Result<()> {
    cmd("chronyc", ["-a", "makestep"])
        .stderr_capture()
        .stdout_capture()
        .run()
        .inspect_err(|err| {
            let _ = logger.log(
                LogLevel::Minimal,
                "install.ops.chrony.error",
                Some(&err.to_string()),
            );
        })?;
    logger.log(LogLevel::Minimal, "install.ops.chrony", None)?;
    Ok(())
}

#[cfg(unix)]
fn apply_secure_umask() {
    use std::sync::Once;
    static INIT: Once = Once::new();
    INIT.call_once(|| unsafe {
        libc::umask(0o077);
    });
}

#[cfg(not(unix))]
fn apply_secure_umask() {}

#[cfg(test)]
mod tests {
    use super::*;
    use serial_test::serial;

    #[test]
    #[serial]
    fn provision_creates_configs() {
        let dir = tempfile::tempdir().unwrap();
        let bin_dir = dir.path().join("bin");
        std::fs::create_dir_all(&bin_dir).unwrap();
        let log_path = dir.path().join("invocations.log");
        for name in ["certbot", "rspamadm", "systemctl", "chronyc"] {
            let script_path = bin_dir.join(name);
            let script = format!(
                "#!/bin/sh\necho \"{name} $@\" >> \"{}\"\nexit 0\n",
                log_path.display()
            );
            std::fs::write(&script_path, script).unwrap();
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                let mut perms = std::fs::metadata(&script_path).unwrap().permissions();
                perms.set_mode(0o755);
                std::fs::set_permissions(&script_path, perms).unwrap();
            }
        }
        let original_path = std::env::var_os("PATH");
        let mut new_path = std::ffi::OsString::from(&bin_dir);
        if let Some(ref orig) = original_path {
            new_path.push(":");
            new_path.push(orig);
        }
        unsafe { std::env::set_var("PATH", &new_path) };

        let layout = MailLayout::new(dir.path());
        layout.ensure().unwrap();
        let env = EnvConfig::default();
        let logger = Logger::new(layout.root(), LogLevel::Minimal).unwrap();
        provision(&layout, &env, &logger).unwrap();
        match original_path {
            Some(path) => unsafe { std::env::set_var("PATH", path) },
            None => unsafe { std::env::remove_var("PATH") },
        }
        assert!(layout.root().join("config/postfix/main.cf").exists());
        assert!(
            layout
                .root()
                .join("config/rspamd/local.d/rate_limit.conf")
                .exists()
        );
        assert!(layout.root().join("config/letsencrypt/README.txt").exists());
        assert!(layout.root().join("logs/chrony-sync.log").exists());
        let log = std::fs::read_to_string(&log_path).unwrap();
        assert!(log.contains("certbot certonly"));
        assert!(log.contains("rspamadm configtest"));
        assert!(log.contains("systemctl enable rspamd"));
        assert!(log.contains("systemctl restart rspamd"));
        assert!(log.contains("systemctl reload postfix"));
        assert!(log.contains("chronyc -a makestep"));
    }

    #[test]
    fn create_rate_limit_marker_skips_existing_file() {
        let dir = tempfile::tempdir().unwrap();
        let layout = MailLayout::new(dir.path());
        layout.ensure().unwrap();
        let chrony = layout.root().join("logs/chrony-sync.log");
        std::fs::create_dir_all(chrony.parent().unwrap()).unwrap();
        std::fs::write(&chrony, "marker").unwrap();
        create_rate_limit_marker(&layout).unwrap();
        let contents = std::fs::read_to_string(&chrony).unwrap();
        assert_eq!(contents, "marker");
    }

    fn write_exec(dir: &tempfile::TempDir, name: &str, body: &str) {
        let path = dir.path().join(name);
        std::fs::write(&path, body).unwrap();
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = std::fs::metadata(&path).unwrap().permissions();
            perms.set_mode(0o755);
            std::fs::set_permissions(&path, perms).unwrap();
        }
    }

    fn with_path_override<T>(dir: &tempfile::TempDir, f: impl FnOnce() -> T) -> T {
        let original = std::env::var_os("PATH");
        let mut new_path = std::ffi::OsString::from(dir.path());
        if let Some(ref orig) = original {
            new_path.push(":");
            new_path.push(orig);
        }
        unsafe { std::env::set_var("PATH", &new_path) };
        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(f));
        match original {
            Some(path) => unsafe { std::env::set_var("PATH", path) },
            None => unsafe { std::env::remove_var("PATH") },
        }
        result.expect("path override panicked")
    }

    #[test]
    #[serial]
    fn enable_rspamd_logs_failures() {
        let dir = tempfile::tempdir().unwrap();
        let layout = MailLayout::new(dir.path());
        layout.ensure().unwrap();
        let logger = Logger::new(layout.root(), LogLevel::Minimal).unwrap();
        write_exec(&dir, "systemctl", "#!/bin/sh\nexit 0\n");
        write_exec(&dir, "rspamadm", "#!/bin/sh\nexit 1\n");
        with_path_override(&dir, || enable_rspamd(&logger).unwrap_err());
        write_exec(&dir, "rspamadm", "#!/bin/sh\nexit 0\n");
        write_exec(
            &dir,
            "systemctl",
            "#!/bin/sh\nif [ \"$1\" = \"enable\" ]; then exit 1; fi\nexit 0\n",
        );
        with_path_override(&dir, || enable_rspamd(&logger).unwrap_err());
        write_exec(
            &dir,
            "systemctl",
            "#!/bin/sh\nif [ \"$1\" = \"restart\" ]; then exit 1; fi\nexit 0\n",
        );
        with_path_override(&dir, || enable_rspamd(&logger).unwrap_err());
        let entries = Logger::load_entries(&logger.log_path()).unwrap();
        assert!(
            entries
                .iter()
                .any(|e| e.message == "install.ops.rspamd.error")
        );
        assert!(
            entries
                .iter()
                .any(|e| e.message == "install.ops.rspamd.enable_error")
        );
        assert!(
            entries
                .iter()
                .any(|e| e.message == "install.ops.rspamd.restart_error")
        );
    }

    #[test]
    #[serial]
    fn with_path_override_restores_missing_path() {
        let dir = tempfile::tempdir().unwrap();
        let original = std::env::var_os("PATH");
        unsafe { std::env::remove_var("PATH") };
        write_exec(&dir, "noop", "#!/bin/sh\nexit 0\n");
        let seen = with_path_override(&dir, || std::env::var_os("PATH").is_some());
        assert!(seen);
        assert!(std::env::var_os("PATH").is_none());
        match original {
            Some(path) => unsafe { std::env::set_var("PATH", path) },
            None => unsafe { std::env::remove_var("PATH") },
        }
    }

    #[test]
    #[serial]
    fn reload_postfix_logs_failures() {
        let dir = tempfile::tempdir().unwrap();
        write_exec(&dir, "systemctl", "#!/bin/sh\nexit 1\n");
        let layout = MailLayout::new(dir.path());
        layout.ensure().unwrap();
        let logger = Logger::new(layout.root(), LogLevel::Minimal).unwrap();
        with_path_override(&dir, || {
            reload_postfix(&logger).unwrap_err();
        });
        let entries = Logger::load_entries(&logger.log_path()).unwrap();
        assert!(
            entries
                .iter()
                .any(|e| e.message == "install.ops.postfix.error")
        );
    }

    #[test]
    #[serial]
    fn sync_chrony_logs_failures() {
        let dir = tempfile::tempdir().unwrap();
        write_exec(&dir, "chronyc", "#!/bin/sh\nexit 1\n");
        let layout = MailLayout::new(dir.path());
        layout.ensure().unwrap();
        let logger = Logger::new(layout.root(), LogLevel::Minimal).unwrap();
        with_path_override(&dir, || {
            sync_chrony(&logger).unwrap_err();
        });
        let entries = Logger::load_entries(&logger.log_path()).unwrap();
        assert!(
            entries
                .iter()
                .any(|e| e.message == "install.ops.chrony.error")
        );
    }

    #[test]
    #[serial]
    fn run_certbot_logs_failures() {
        let dir = tempfile::tempdir().unwrap();
        write_exec(&dir, "certbot", "#!/bin/sh\nexit 1\n");
        let env = EnvConfig::default();
        let layout = MailLayout::new(dir.path());
        layout.ensure().unwrap();
        let logger = Logger::new(layout.root(), LogLevel::Minimal).unwrap();
        with_path_override(&dir, || {
            run_certbot(&layout, &env, &logger).unwrap_err();
        });
        let entries = Logger::load_entries(&logger.log_path()).unwrap();
        assert!(
            entries
                .iter()
                .any(|e| e.message == "install.ops.certbot.error")
        );
    }

    #[test]
    #[serial]
    fn run_certbot_uses_domain_without_smtp_prefix() {
        let dir = tempfile::tempdir().unwrap();
        let layout = MailLayout::new(dir.path());
        layout.ensure().unwrap();

        let env = EnvConfig {
            letsencrypt_method: "dns".into(),
            smtp_host: Some("smtp.example.com".into()),
            ..EnvConfig::default()
        };
        create_letsencrypt_docs(&layout, &env).unwrap();
        let logger = Logger::new(layout.root(), LogLevel::Minimal).unwrap();

        let args_log = dir.path().join("certbot-args.log");
        let script = format!(
            "#!/bin/sh\nprintf '%s\\n' \"$@\" > \"{}\"\n",
            args_log.display()
        );
        write_exec(&dir, "certbot", &script);

        with_path_override(&dir, || {
            run_certbot(&layout, &env, &logger).unwrap();
        });

        let contents = std::fs::read_to_string(&args_log).unwrap();
        assert!(contents.contains("--email"));
        assert!(contents.contains("postmaster@example.com"));
        assert!(contents.contains("-d"));
        assert!(contents.contains("smtp.example.com"));
        assert!(!contents.contains("--preferred-challenges"));

        let entries = Logger::load_entries(&logger.log_path()).unwrap();
        assert!(entries.iter().any(|e| e.message == "install.ops.certbot"));
        assert!(entries.iter().any(|e| {
            e.detail
                .as_deref()
                .map(|detail| detail.contains("domain=smtp.example.com"))
                .unwrap_or(false)
        }));
    }
}
